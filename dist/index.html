<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <!-- Mobile fullscreen/PWA hints -->
    <meta name="theme-color" content="#000000" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="mobile-web-app-capable" content="yes" />
    <link rel="manifest" href="/boom/manifest.webmanifest" />
    <meta name="screen-orientation" content="landscape" />
    <meta
      name="google-site-verification"
      content="%VITE_GOOGLE_VERIFICATION_ID%"
    />

    <link rel="icon" type="image/x-icon" href="/boom/favicon.ico" />
    <!-- Preload font to use in Phaser.js, otherwise it will be taken as a fallback (I don't know the reason) -->
    <link
      rel="preload"
      as="font"
      type="font/ttf"
      href="/boom/fonts/BitBold.ttf"
      crossorigin
    />
    <link rel="stylesheet" href="/boom/styles/global.css" />
    <link rel="stylesheet" href="/boom/styles/dialog.css" />

    <title>Bomberman (NES)</title>
    <script type="module" crossorigin src="/boom/assets/index-CYdl5FRv.js"></script>
    <link rel="modulepreload" crossorigin href="/boom/assets/phaser-DJc9ez-r.js">
  </head>
  <body>
    <script>
      // Attempt to enter fullscreen on first user interaction (mobile browsers require gesture)
      (function () {
        let requested = false;
        function requestFs() {
          if (requested) return;
          requested = true;
          const el = document.documentElement;
          const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
          if (req) {
            try { req.call(el); } catch (e) { /* ignore */ }
          }
          // Best-effort hide URL bar on older mobile browsers
          setTimeout(() => window.scrollTo(0, 1), 50);
        }
        window.addEventListener('pointerdown', requestFs, { once: true, passive: true });
        window.addEventListener('touchstart', requestFs, { once: true, passive: true });
      })();
    </script>
    <script>
      // Auto-rotate to landscape on mobile
      (function () {
        function lockOrientation() {
          // Check if device is mobile
          const isMobile =
            /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
              navigator.userAgent.toLowerCase()
            ) ||
            (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);

          if (!isMobile) return;

          // Try to lock orientation to landscape
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation
              .lock('landscape')
              .then(() => {
                console.log('Screen orientation locked to landscape');
              })
              .catch((err) => {
                console.log('Could not lock orientation:', err);
              });
          } else if (screen.lockOrientation) {
            // Fallback for older browsers
            screen.lockOrientation('landscape');
          } else if (screen.mozLockOrientation) {
            // Firefox
            screen.mozLockOrientation('landscape');
          } else if (screen.msLockOrientation) {
            // IE/Edge
            screen.msLockOrientation('landscape');
          }
        }

        // Lock on load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', lockOrientation);
        } else {
          lockOrientation();
        }

        // Also try on orientation change (in case user rotates back)
        window.addEventListener('orientationchange', () => {
          setTimeout(lockOrientation, 100);
        });

        // Try when window becomes visible (handles tab switching)
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden) {
            setTimeout(lockOrientation, 100);
          }
        });
      })();
    </script>
    <script>
      // Mobile device detection - runs immediately before DOM is ready
      (function () {
        function detectMobileDevice() {
          // Check for touch capability
          const hasTouch =
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            (window.matchMedia &&
              window.matchMedia('(pointer: coarse)').matches);

          // Check user agent for mobile/tablet patterns
          const userAgent =
            navigator.userAgent || navigator.vendor || window.opera || '';
          const isMobileUA =
            /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
              userAgent.toLowerCase()
            );

          // Check for tablet (iPad Pro has mouse but is still a tablet)
          const isTablet = /ipad|android(?!.*mobile)|tablet/i.test(
            userAgent.toLowerCase()
          );

          // Consider it mobile if:
          // 1. Has touch capability AND (mobile UA OR tablet), OR
          // 2. Screen width suggests mobile device with touch
          const isMobile =
            hasTouch && (isMobileUA || isTablet || window.innerWidth <= 1024);

          if (isMobile) {
            document.body.classList.add('is-mobile-device');
            document.documentElement.classList.add('is-mobile-device');
          } else {
            document.body.classList.remove('is-mobile-device');
            document.documentElement.classList.remove('is-mobile-device');
          }

          return isMobile;
        }

        // Run immediately when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', detectMobileDevice);
        } else {
          detectMobileDevice();
        }

        // Also run on resize/orientation change (in case device is rotated or browser is resized)
        var resizeTimeout;
        window.addEventListener('resize', function () {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(detectMobileDevice, 150);
        });

        window.addEventListener('orientationchange', function () {
          setTimeout(detectMobileDevice, 100);
        });
      })();
    </script>
    <script>
      // Try to enter fullscreen on first interaction (mobile browsers require user gesture)
      (function () {
        function isMobile() {
          const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const ua = (navigator.userAgent || navigator.vendor || window.opera || '').toLowerCase();
          return hasTouch && /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|tablet/.test(ua);
        }

        function requestFs() {
          const root = document.documentElement;
          const anyRoot = root;
          const req = root.requestFullscreen || anyRoot.webkitRequestFullscreen || anyRoot.msRequestFullscreen || anyRoot.mozRequestFullScreen;
          if (req) {
            try { req.call(root); } catch (e) { /* ignore */ }
          }
        }

        if (isMobile()) {
          const once = () => {
            requestFs();
            window.removeEventListener('touchstart', once);
            window.removeEventListener('click', once);
          };
          window.addEventListener('touchstart', once, { passive: true });
          window.addEventListener('click', once, { passive: true });
        }
      })();
    </script>
    <main>
      <!-- Rotate device message for portrait mode -->
      <div id="rotate-message">
        <div>ðŸ“±</div>
        <div>Xoay ngang mÃ n hÃ¬nh</div>
        <div>Vui lÃ²ng xoay thiáº¿t bá»‹ sang cháº¿ Ä‘á»™ ngang Ä‘á»ƒ chÆ¡i game</div>
      </div>

      <div id="bomberman-container"></div>


      <!-- <div id="game-controls">
        <button onclick="constrolsModal.showModal()">How to play?</button>
      </div> -->

      <!-- Mobile Touch Controls -->
      <div id="mobile-controls">
        <div class="mobile-controls-grid">
          <div class="mobile-controls-left">
            <!-- Joystick -->
            <div id="joystick-container">
              <div id="joystick-base"></div>
              <div id="joystick-stick"></div>
            </div>
          </div>
          <!-- <div class="mobile-controls-center">
            <div id="mobile-game-controls">
              <button onclick="constrolsModal.showModal()">How to play?</button>
            </div>
          </div> -->
          <div class="mobile-controls-right">
            <button
              onmousedown="event.stopPropagation(); if(window.touchControlPutBomb) window.touchControlPutBomb(true)"
              onmouseup="event.stopPropagation(); if(window.touchControlPutBomb) window.touchControlPutBomb(false)"
              ontouchstart="event.preventDefault(); event.stopPropagation(); if(window.touchControlPutBomb) window.touchControlPutBomb(true)"
              ontouchend="event.preventDefault(); event.stopPropagation(); if(window.touchControlPutBomb) window.touchControlPutBomb(false)"
              aria-label="Put Bomb"
            >
              ðŸ’£ BOMB
            </button>
            <!-- <button
              onmousedown="if(window.touchControlExploitBomb) window.touchControlExploitBomb(true)"
              onmouseup="if(window.touchControlExploitBomb) window.touchControlExploitBomb(false)"
              ontouchstart="event.preventDefault(); if(window.touchControlExploitBomb) window.touchControlExploitBomb(true)"
              ontouchend="event.preventDefault(); if(window.touchControlExploitBomb) window.touchControlExploitBomb(false)"
              aria-label="Explode Bomb"
            >
              ðŸ’¥ EXPLODE
            </button> -->
          </div>
        </div>
      </div>

      <dialog id="constrolsModal">
        <form method="dialog" class="btn-close">
          <button type="submit" autofocus>x</button>
        </form>

        <div class="dialog-body">
          <section>
            <div>
              <img
                src="/boom/images/arrow-keys.png"
                width="90"
                height="60"
                alt="Key Up"
              />
            </div>

            <p>To move your player</p>
          </section>

          <section>
            <img src="/boom/images/x-key.png" width="60" height="60" alt="Key Up" />

            <p>To put any bomb</p>
          </section>

          <section>
            <img
              src="/boom/images/space-key.png"
              width="60"
              height="60"
              alt="Key Up"
            />

            <p>To explode a bomb</p>
          </section>

          <section>
            <img src="/boom/images/s-key.png" width="60" height="60" alt="Key Up" />

            <p>To save the game</p>
          </section>
        </div>
      </dialog>
    </main>

    <!-- Github Button -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>

    <!-- Joystick Control Script -->
    <script>
      (function () {
        const joystickContainer = document.getElementById('joystick-container');
        const joystickStick = document.getElementById('joystick-stick');

        if (!joystickContainer || !joystickStick) return;

        let isActive = false;
        let centerX = 0;
        let centerY = 0;
        let maxDistance = 0;
        let currentPointerId = null;
        let currentDirection = {
          up: false,
          down: false,
          left: false,
          right: false
        };
        let lastDirection = {
          up: false,
          down: false,
          left: false,
          right: false
        };

        // Calculate center and max distance
        function updateJoystickBounds() {
          const rect = joystickContainer.getBoundingClientRect();
          centerX = rect.left + rect.width / 2;
          centerY = rect.top + rect.height / 2;
          maxDistance = rect.width / 2 - 5;
        }

        // Calculate direction based on dx and dy - smart turning detection
        function getDirectionFromDeltas(dx, dy) {
          const absDx = Math.abs(dx);
          const absDy = Math.abs(dy);
          
          // Threshold for activation
          const threshold = 5; // pixels
          
          // Calculate total distance
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // If movement is too small, return no direction
          if (distance < threshold) {
            return { up: false, down: false, left: false, right: false };
          }
          
          // Check if we're turning (changing from one axis to another)
          const wasHorizontal = lastDirection.left || lastDirection.right;
          const wasVertical = lastDirection.up || lastDirection.down;
          
          // Determine which axis is dominant
          const horizontalRatio = absDx / (absDx + absDy);
          const verticalRatio = absDy / (absDx + absDy);
          
          // Very aggressive threshold (90%) for clean single-direction input
          // When turning, use even higher threshold (95%) to ensure clean direction change
          const isTurning = (wasHorizontal && absDy > absDx) || (wasVertical && absDx > absDy);
          const turnThreshold = isTurning ? 0.95 : 0.90;
          
          const horizontalDominant = horizontalRatio > turnThreshold;
          const verticalDominant = verticalRatio > turnThreshold;
          
          let left = false, right = false, up = false, down = false;
          
          if (horizontalDominant) {
            // Horizontal movement is clearly dominant - only use horizontal
            if (absDx > threshold) {
              left = dx < 0;
              right = dx > 0;
            }
          } else if (verticalDominant) {
            // Vertical movement is clearly dominant - only use vertical
            if (absDy > threshold) {
              up = dy < 0;
              down = dy > 0;
            }
          } else {
            // Similar strength - when turning, prioritize the new direction ONLY
            if (isTurning) {
              // We're turning - ONLY send the new direction, ignore the old one
              if (wasHorizontal && absDy > threshold) {
                // Was moving horizontal, now turning vertical - ONLY send vertical
                up = dy < 0;
                down = dy > 0;
                // Explicitly disable horizontal to prevent conflict
                left = false;
                right = false;
              } else if (wasVertical && absDx > threshold) {
                // Was moving vertical, now turning horizontal - ONLY send horizontal
                left = dx < 0;
                right = dx > 0;
                // Explicitly disable vertical to prevent conflict
                up = false;
                down = false;
              }
            } else {
              // Not turning - prioritize the stronger one
              if (absDx > absDy * 1.15) {
                // Horizontal is noticeably stronger (15% more)
                if (absDx > threshold) {
                  left = dx < 0;
                  right = dx > 0;
                }
              } else if (absDy > absDx * 1.15) {
                // Vertical is noticeably stronger (15% more)
                if (absDy > threshold) {
                  up = dy < 0;
                  down = dy > 0;
                }
              } else {
                // Very similar - use the one that's slightly stronger
                if (absDx > absDy) {
                  if (absDx > threshold) {
                    left = dx < 0;
                    right = dx > 0;
                  }
                } else {
                  if (absDy > threshold) {
                    up = dy < 0;
                    down = dy > 0;
                  }
                }
              }
            }
          }

          return { up, down, left, right };
        }

        // Update controls and visual position - instant and responsive
        function updateJoystick(x, y) {
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Limit distance to max for visual stick
          const limitedDistance = Math.min(distance, maxDistance);
          const angle = Math.atan2(dy, dx);

          // Calculate stick position
          const stickX = Math.cos(angle) * limitedDistance;
          const stickY = Math.sin(angle) * limitedDistance;

          // Update visual position instantly - no transition during movement
          joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
          joystickStick.style.transition = 'none';

          // Calculate direction based on deltas - instant response with smart turning
          const newDirection = getDirectionFromDeltas(dx, dy);
          
          // Update controls immediately for instant response
          // Always call these functions to ensure state is updated
          if (typeof window.touchControlLeft === 'function') {
            window.touchControlLeft(newDirection.left);
          }
          if (typeof window.touchControlRight === 'function') {
            window.touchControlRight(newDirection.right);
          }
          if (typeof window.touchControlUp === 'function') {
            window.touchControlUp(newDirection.up);
          }
          if (typeof window.touchControlDown === 'function') {
            window.touchControlDown(newDirection.down);
          }
          
          // Store current direction and update last direction for turning detection
          currentDirection = newDirection;
          lastDirection = { ...newDirection };
        }

        // Reset joystick to center
        function resetJoystick() {
          joystickStick.style.transform = 'translate(-50%, -50%)';
          joystickStick.style.transition = 'transform 0.15s ease-out'; // Smooth return to center
          joystickStick.classList.remove('active');
          isActive = false;
          currentPointerId = null;

          // Reset all controls immediately - ensure functions exist before calling
          if (typeof window.touchControlUp === 'function') window.touchControlUp(false);
          if (typeof window.touchControlDown === 'function') window.touchControlDown(false);
          if (typeof window.touchControlLeft === 'function') window.touchControlLeft(false);
          if (typeof window.touchControlRight === 'function') window.touchControlRight(false);
          
          currentDirection = {
            up: false,
            down: false,
            left: false,
            right: false
          };
          lastDirection = {
            up: false,
            down: false,
            left: false,
            right: false
          };
        }

        // Get pointer coordinates (works for both mouse and touch)
        function getCoordinates(e) {
          if (e.pointerId !== undefined) {
            // Pointer event
            return { x: e.clientX, y: e.clientY };
          } else if (e.touches && e.touches.length > 0) {
            // Touch event
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          // Mouse event
          return { x: e.clientX, y: e.clientY };
        }

        // Start handlers - use Pointer Events for better cross-platform support
        function onStart(e) {
          e.preventDefault();
          updateJoystickBounds();
          isActive = true;
          currentPointerId = e.pointerId !== undefined ? e.pointerId : null;
          joystickStick.classList.add('active');
          
          const coords = getCoordinates(e);
          updateJoystick(coords.x, coords.y);
        }

        // Move handlers
        function onMove(e) {
          if (!isActive) return;
          
          // For pointer events, check if it's the same pointer
          if (e.pointerId !== undefined && currentPointerId !== null && e.pointerId !== currentPointerId) {
            return;
          }
          
          e.preventDefault();
          const coords = getCoordinates(e);
          updateJoystick(coords.x, coords.y);
        }

        // End handlers
        function onEnd(e) {
          if (!isActive) return;
          
          // For pointer events, check if it's the same pointer
          if (e.pointerId !== undefined && currentPointerId !== null && e.pointerId !== currentPointerId) {
            return;
          }
          
          resetJoystick();
        }

        // Use Pointer Events for better cross-platform support (mouse + touch)
        if (window.PointerEvent) {
          joystickContainer.addEventListener('pointerdown', onStart, { passive: false });
          document.addEventListener('pointermove', onMove, { passive: false });
          document.addEventListener('pointerup', onEnd);
          document.addEventListener('pointercancel', onEnd);
        } else {
          // Fallback for older browsers
          joystickContainer.addEventListener('mousedown', onStart);
          joystickContainer.addEventListener('touchstart', onStart, { passive: false });
          document.addEventListener('mousemove', onMove);
          document.addEventListener('touchmove', onMove, { passive: false });
          document.addEventListener('mouseup', onEnd);
          document.addEventListener('touchend', onEnd);
          document.addEventListener('touchcancel', onEnd);
        }

        // Update bounds on resize
        window.addEventListener('resize', updateJoystickBounds);
        updateJoystickBounds();
      })();
    </script>
  </body>
</html>
